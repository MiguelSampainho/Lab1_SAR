package com.sar.web.http;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream; // Needed for writeFile
import java.io.IOException;     // Needed for send_Answer, writeFile
import java.io.PrintStream;   // Needed for send_Answer, writeFile
import java.nio.charset.StandardCharsets; // Needed for setTextHeaders, generateErrorPage
import java.text.DateFormat;    // Needed for DateUtil
import java.text.ParseException;// Needed for StaticFileHandler potentially (though handled there)
import java.text.SimpleDateFormat; // Needed for DateUtil
import java.util.*;             // Needed for Date, List, ArrayList, TimeZone, Locale, Enumeration

public class Response {
    // Logger IS used now
    private static final Logger logger = LoggerFactory.getLogger(Response.class);

    public ReplyCode code;
    public Headers headers;
    public List<String> setCookieHeaders;
    public String text;
    public File file;
    // serverName IS used in generateErrorPage
    private final String serverName;

    public Response(String server_name) {
        this.code = new ReplyCode();
        this.headers = new Headers();
        this.setCookieHeaders = new ArrayList<>();
        this.serverName = server_name;
        this.headers.setHeader("Server", server_name);
    }

    // Static inner class for Date Formatting - With ThreadLocal
    public static class DateUtil {
        private static final ThreadLocal<DateFormat> HTTP_DATE_FORMATTER =
            ThreadLocal.withInitial(() -> {
                SimpleDateFormat formatter = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.UK);
                formatter.setTimeZone(TimeZone.getTimeZone("GMT"));
                return formatter;
            });

        public static String getHTTPDate(Date date) {
            return HTTP_DATE_FORMATTER.get().format(date);
        }

        public static DateFormat getHTTPDateFormatter() {
            return HTTP_DATE_FORMATTER.get();
        }
    }

    // --- Restored Methods ---

    public void setCode(int _code) { code.setCode(_code); }
    public void setVersion(String v) { code.setVersion(v); }
    public void setHeader(String name, String value) { headers.setHeader(name, value); }
    public void setFile(File file) { this.file = file; this.text = null; }
    public void setText(String text) { this.text = text; this.file = null; }

    public void addSetCookieHeader(String fullCookieHeaderString) {
        if (fullCookieHeaderString != null && !fullCookieHeaderString.isEmpty()) {
            this.setCookieHeaders.add(fullCookieHeaderString);
            logger.debug("Adding Set-Cookie header: {}", fullCookieHeaderString);
        }
    }

    public void setFileHeaders(File file, String contentType) {
        this.file = file;
        this.text = null;
        if(file != null && file.exists()){
            headers.setHeader("Last-Modified", DateUtil.getHTTPDate(new Date(file.lastModified())));
            headers.setHeader("Content-Type", contentType);
            headers.setHeader("Content-Length", String.valueOf(file.length()));
            if (contentType.startsWith("text/")) {
                headers.setHeader("Content-Type", contentType + "; charset=ISO-8859-1");
            }
        } else {
            logger.warn("Invalid or non-existent file in setFileHeaders(): {}", file != null ? file.getPath() : "null");
        }
        logger.debug("File headers set for: {}", file != null ? file.getName() : "null file");
    }

    public void setTextHeaders(String text) {
        this.text = text;
        this.file = null;
        headers.setHeader("Content-Type", "text/html; charset=UTF-8");
        headers.setHeader("Content-Length", String.valueOf(text != null ? text.getBytes(StandardCharsets.UTF_8).length : 0));
        logger.debug("Text headers set (Content-Type: text/html; charset=UTF-8).");
    }

    public void setError(int codeNumber, String version) {
        setVersion(version != null ? version : "HTTP/1.1");
        code.setCode(codeNumber);
        String errorHtml = generateErrorPage(codeNumber);
        setTextHeaders(errorHtml);
        setDate();
        setHeader("Connection", "close");
    }

    private String generateErrorPage(int codeNumber) {
        String codeText = ReplyCode.codeText(codeNumber);
        // Use serverName here
        return String.format(
            "<!DOCTYPE html><html><head><title>Error %d</title></head><body><h1>Error %d - %s</h1><p>Generated by %s</p></body></html>",
            codeNumber, codeNumber, codeText != null ? codeText : "Unknown Error", this.serverName
        );
    }

    public int getCode() { return code.getCode(); }
    public Enumeration<String> getAllHeaderNames() { return headers.getAllHeaderNames(); }

    public void setDate() {
        headers.setHeader("Date", DateUtil.getHTTPDate(new Date()));
    }

    public void send_Answer(PrintStream TextPrinter) throws IOException { // Requires PrintStream, IOException
        if (code.isUndef()) {
            logger.error("Response code is undefined before sending. Setting to 400.");
            setError(ReplyCode.BADREQ, "HTTP/1.1");
        }
        if (headers.getHeaderValue("Date") == null) {
           setDate();
        }

        logger.info("Sending reply: {} {} {}", code.getVersion(), code.getCode(), code.getCodeTxt());
        TextPrinter.print(code.toString() + "\r\n");

        headers.writeHeaders(TextPrinter);

        if (setCookieHeaders != null && !setCookieHeaders.isEmpty()) {
           for (String cookieHeaderValue : setCookieHeaders) {
               TextPrinter.print("Set-Cookie: " + cookieHeaderValue + "\r\n");
               logger.debug("Writing Set-Cookie header: {}", cookieHeaderValue);
           }
        }

        TextPrinter.print("\r\n");

        boolean sendBody = code.getCode() != ReplyCode.NOTMODIFIED &&
                           code.getCode() != 204 &&
                           code.getCode() != ReplyCode.TMPREDIRECT;

        if (sendBody) {
            if (text != null) {
                TextPrinter.print(text);
            } else if (file != null) {
                writeFile(TextPrinter); // Requires FileInputStream, IOException
            } else {
                if (code.getCode() >= 200 && code.getCode() < 300 && code.getCode() != 204) {
                   logger.warn("Response body (text or file) is null for status code {}", code.getCode());
                }
            }
        } else {
            logger.debug("No body content sent for status code {}", code.getCode());
        }

        TextPrinter.flush();
        logger.debug("Response flushed.");
    }

    private void writeFile(PrintStream TextPrinter) throws IOException { // Requires FileInputStream, IOException
        if (file == null || !file.exists()) {
            logger.error("Attempted to write null or non-existent file.");
            return;
        }
        try (FileInputStream fin = new FileInputStream(file)) { // Requires FileInputStream
            byte[] buffer = new byte[4096];
            int bytesRead;
            long totalBytes = file.length();
            long writtenBytes = 0;
            logger.debug("Starting file transfer for {} ({} bytes)...", file.getName(), totalBytes);
            while ((bytesRead = fin.read(buffer)) != -1) {
                TextPrinter.write(buffer, 0, bytesRead);
                writtenBytes += bytesRead;
            }
            if (writtenBytes != totalBytes) {
                logger.warn("File write size mismatch for {}: expected {}, wrote {}", file.getName(), totalBytes, writtenBytes);
            }
            logger.debug("Finished file transfer for {}.", file.getName());
        } catch (IOException e) { // Requires IOException
            logger.error("I/O error sending file {}: {}", file.getName(), e.getMessage());
            // Re-throw or handle appropriately if needed, but often just logging is okay here
            // Re-throwing simplifies the method signature.
            throw e;
        }
    }

} // End of class
